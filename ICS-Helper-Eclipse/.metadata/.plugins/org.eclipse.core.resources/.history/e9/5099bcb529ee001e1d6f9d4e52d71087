/*
 * generated by Xtext 2.34.0
 */
package ics.helper.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ics.helper.helperDSL.CreateCommand
import ics.helper.helperDSL.RecurRule
import java.text.SimpleDateFormat
import java.util.Date
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.time.ZoneId;
import java.time.format.DateTimeParseException;


/**
 * Generates ICS files from your model files on save.
 */
class HelperDSLGenerator extends AbstractGenerator {
	private final DateTimeFormatter userInputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
    private final DateTimeFormatter icsFormatter = DateTimeFormatter.ofPattern("yyyyMMdd'T'HHmmss'Z'").withZone(ZoneId.of("UTC"));

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        for (e : resource.allContents.toIterable.filter(CreateCommand)) {
            generateICSFile(e, fsa)
        }
    }

    def generateICSFile(CreateCommand command, IFileSystemAccess2 fsa) {
        val StringBuilder icsContent = new StringBuilder()
        icsContent.append("BEGIN:VCALENDAR\n")
        icsContent.append("VERSION:2.0\n")
        icsContent.append("PRODID:-//hacksw/handcal//NONSGML v1.0//EN\n")
        
        for (event : command.events) {
            icsContent.append("BEGIN:VEVENT\n")
            icsContent.append("SUMMARY:" + event.name + "\n")
            icsContent.append("DTSTART:" + convertToICSTimeFormat(event.startTime) + "\n")
            icsContent.append("DTEND:" + convertToICSTimeFormat(event.endTime) + "\n")
            if (event.location !== null) {
                icsContent.append("LOCATION:" + event.location + "\n")
            }
            if (event.description !== null) {
                icsContent.append("DESCRIPTION:" + event.description + "\n")
            }
            if (event.link !== null) {
                icsContent.append("LINK:" + event.link + "\n")
            }
            if (event.recur !== null) {
                icsContent.append(generateRecurRule(event.recur) + "\n")
            }
            icsContent.append("END:VEVENT\n")
        }
        
        icsContent.append("END:VCALENDAR")
        
        // Generate the ICS file in the 'ics-gen' directory
        val fileName = "ics-gen/" + command.name + ".ics"
        fsa.generateFile(fileName, icsContent.toString)
    }
    
    def String generateRecurRule(RecurRule recur) {
    	if (recur === 'daily'){
    		return "RRULE:FREQ=DAILY";
    	}
    	
//        switch recur {
//            case 'daily': "RRULE:FREQ=DAILY"
//            case 'weekly': "RRULE:FREQ=WEEKLY"
//            case 'monthly': "RRULE:FREQ=MONTHLY"
//            case 'yearly': "RRULE:FREQ=YEARLY"
//            default: {
//                val days = recur.daysOfWeek.day.join(",")
//                "RRULE:FREQ=WEEKLY;BYDAY=" + days.toUpperCase
//            }
//        }
    }
    def String convertToICSTimeFormat(String userInputTime) {
        try {
            val LocalDateTime dateTime = LocalDateTime.parse(userInputTime, userInputFormatter);
            return icsFormatter.format(dateTime);
        } catch (DateTimeParseException e) {
            System.err.println("Failed to parse date time: " + userInputTime);
            return "";
        }
    }
}
